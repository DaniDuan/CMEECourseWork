# This function calculates height of trees given distance of each tree
# from its base and angle to its top, using the trigonometric formula
#
# height = distance * tan(radians)
#
# ARGUEMENTS
# degrees: The angle of elevation of tree
# distance The distance from base of tree (e.g. meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"
MyData = read.csv("../data/trees.csv", header = T)
Distance.m = MyData$Distance.m
Angle.degrees = MyData$Angle.degrees
Species = MyData$Species
TreeHeight = function(degrees,distance){
radians = degrees * pi / 100
height = distance * tan(radians)
print(paste("Tree height is:",height))
return(height)
}
Tree.Height.m = TreeHeight(Angle.degrees,Distance.m)
TreeHts = data.frame(Species, Distance.m, Angle.degrees, Tree.Height.m)
names(TreeHts) = c("Species", "Distance.m", "Angle.degrees", "Tree.Height.m")
TreeHts
write.table(TreeHts, "../results/TreeHts.csv", row.names = F)
a = 1.0
class(a)
float(a)
float a
M = matrix(runif(1000000), 1000, 1000)
SumAllElements = function(M){
Dimensions = dim(M)
Tot = 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot = Tot + M[i,j]
}
}
return(Tot)
}
print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))
print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
M = matrix(runif(1000000), 1000, 1000)
SumAllElements = function(M){
Dimensions = dim(M)
Tot = 0
for (i in 1:Dimensions[1]){
for (j in 1:Dimensions[2]){
Tot = Tot + M[i,j]
}
}
return(Tot)
}
print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))
print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
dim(M)
Dimensions[1]
dim(M)[1]
a = NA
for(i in 1:10){
a = c(a, i)
print(a)
print(object.size(a))
}
a = 0
for(i in 1:10){
a = c(a, i)
print(a)
print(object.size(a))
}
dim(a)
runif(20,min=0,max=2)
NoPreallocFun = function(x){
a = vector()
for (i in 1:x){
a = c(a,i)
print(a)
print(object.size(a))
}
}
system.time(NoPreallocFun(10))
PreallocFun = function(x){
a = rep(NA,x){
a[i] = i
print(a)
print(object.size(a))
}
}
system.time(PreallocFun(10))
PreallocFun = function(x){
a = rep(NA,x){
a[i] = i
print(a)
print(object.size(a))
}
}
system.time(PreallocFun(10))
PreallocFun = function(x){
a = rep(NA,x)
for (i in i:x) {
a[i] = i
print(a)
print(object.size(a))
}
}
system.time(PreallocFun(10))
PreallocFun = function(x){
a = rep(NA,x)
for (i in 1:x) {
a[i] = i
print(a)
print(object.size(a))
}
}
system.time(PreallocFun(10))
# Build a random matrix
M = matrix(rnorm(100),10,10)
# Take the mean of each row
RowMeans = apply(M,1,mean)
print(RowMeans)
SomeOperation = function(v){
if(sum(v) > 0){ #note that sum(v) is a single (scalar) value
return (v*100)
}
return(v)
}
M = matrix(rnorm(100), 10, 10)
print(apply(M,1,SomeOperation))
# Build a random matrix
M = matrix(rnorm(100),10,10)
# Take the mean of each row
RowMeans = apply(M,1,mean)
print(RowMeans)
# Now the variance
RowVars = apply(M,1,var)
print(RowVars)
# by column
ColMeans = apply(M, 2, mean)
print(ColMeans)
# Build a random matrix
M = matrix(rnorm(100),10,10)
# Take the mean of each row
RowMeans = apply(M,1,mean)
print(RowMeans)
# variance
RowVars = apply(M,1,var)
print(RowVars)
# by column
ColMeans = apply(M, 2, mean)
print(ColMeans)
SomeOperation = function(v){
if(sum(v) > 0){ #note that sum(v) is a single (scalar) value
return (v*100)
}
return(v)
}
M = matrix(rnorm(100), 10, 10)
print(apply(M,1,SomeOperation))
my_experiment = function(popn,n){
pop_sample = sample(popn,n,replace = F)
return(mean(pop_sample))
}
loopy_sample = function(popn, n, num){
result1 = vector()
for(i in 1:num){
result1 = c(result1,myexperiment(popn, n))
}
return(result1)
}
loopy_sample2 = function(popn, n, num){
result2 = vector(,num) #preallocate expected size
for(i in 1:num){
result2[i] = myexperiment(popn,n)
}
return(result2)
}
loopy_sample3 = function(popn,n,num){
result3 = vector("list", num)
for(i in 1:num){
result3[[i]] = myexperiment(popn,n)
}
return(result3)
}
lapply_sample = function(popn,n,num){
result4 = lapply(1:num,function(i) myexperiment(popn, n))
return(result4)
}
sapply_sample = function(popn,n,num){
result5 = sapply(1:num, function(i) myexperiment(popn,n))
return(result5)
}
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
popn = rnorm(1000)
hist(popn)
loopy_sample1 = function(popn, n, num){
result1 = vector()
for(i in 1:num){
result1 = c(result1,myexperiment(popn, n))
}
return(result1)
}
###### Functions #######
## A function to take a sample of size n from a population "popn" and return its mean
my_experiment = function(popn,n){
pop_sample = sample(popn,n,replace = F)
return(mean(pop_sample))
}
## Calculate means using a for loop without preallocation:
loopy_sample1 = function(popn, n, num){
result1 = vector()
for(i in 1:num){
result1 = c(result1,myexperiment(popn, n))
}
return(result1)
}
## To run "num" iteration of the experiment using a for loop on a vector with preallocation
loopy_sample2 = function(popn, n, num){
result2 = vector(,num) #preallocate expected size
for(i in 1:num){
result2[i] = myexperiment(popn,n)
}
return(result2)
}
## To run "num" iterations of the experiment using vectorization with lapply:
loopy_sample3 = function(popn,n,num){
result3 = vector("list", num)
for(i in 1:num){
result3[[i]] = myexperiment(popn,n)
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply
lapply_sample = function(popn,n,num){
result4 = lapply(1:num,function(i) myexperiment(popn, n))
return(result4)
}
## To run "num" iterations of the experiment using vectorization with lapply
sapply_sample = function(popn,n,num){
result5 = sapply(1:num, function(i) myexperiment(popn,n))
return(result5)
}
popn = rnorm(1000)
hist(popn)
n = 20
num = 1000
print("the loopy, non_preallocation approach takes:")
print(system.time(loopy_sample1(popn, n, num)))
print("the loopy, but with preallocation approach takes:")
print(system.time(loopy_sample2(popn, n, num)))
print("the loopy, non-preallocation approach on a list takes:")
print(system.time(loopy_sample3(popn, n, num)))
print("the vectorized sapply approach takes:")
print(system.time(sapply_sample(popn,n,num)))
print("the vectorized lapply approach takes:")
print(system.time(lapply_sample(popn,n,num)))
###### Functions #######
## A function to take a sample of size n from a population "popn" and return its mean
myexperiment = function(popn,n){
pop_sample = sample(popn,n,replace = F)
return(mean(pop_sample))
}
## Calculate means using a for loop without preallocation:
loopy_sample1 = function(popn, n, num){
result1 = vector()
for(i in 1:num){
result1 = c(result1,myexperiment(popn, n))
}
return(result1)
}
## To run "num" iteration of the experiment using a for loop on a vector with preallocation
loopy_sample2 = function(popn, n, num){
result2 = vector(,num) #preallocate expected size
for(i in 1:num){
result2[i] = myexperiment(popn,n)
}
return(result2)
}
## To run "num" iterations of the experiment using vectorization with lapply:
loopy_sample3 = function(popn,n,num){
result3 = vector("list", num)
for(i in 1:num){
result3[[i]] = myexperiment(popn,n)
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply
lapply_sample = function(popn,n,num){
result4 = lapply(1:num,function(i) myexperiment(popn, n))
return(result4)
}
## To run "num" iterations of the experiment using vectorization with lapply
sapply_sample = function(popn,n,num){
result5 = sapply(1:num, function(i) myexperiment(popn,n))
return(result5)
}
popn = rnorm(1000)
hist(popn)
n = 20
num = 1000
print("the loopy, non_preallocation approach takes:")
print(system.time(loopy_sample1(popn, n, num)))
print("the loopy, but with preallocation approach takes:")
print(system.time(loopy_sample2(popn, n, num)))
print("the loopy, non-preallocation approach on a list takes:")
print(system.time(loopy_sample3(popn, n, num)))
print("the vectorized sapply approach takes:")
print(system.time(sapply_sample(popn,n,num)))
print("the vectorized lapply approach takes:")
print(system.time(lapply_sample(popn,n,num)))
View(my_experiment)
x = 1:20
y = factor(rep(letters[1:5], each = 4))
tapply(x, y, sum)
attach(iris)
iris
attach(iris)
iris
by(iris[,1:2], iris$Species, colMeans)
by(iris[,1:2], iris$Petal.Width, colMeans)
a = c(1,2,3,4,5)
b = sample(a,9,replace = T)
b = sample(a, 9, replace = F)
a = c(1,2,3,4,5)
b = sample(a,4,replace = T)
b = sample(a, 4, replace = F)
b
b
a = c(1,2,3,4,5)
b = sample(a,4,replace = T)
b
c = sample(a, 4, replace = F)
c
head(iris)
replicate(10, runif(5))
head(iris)
by(iris[,1:2], iris$Species, colMeans)
iris[1,1:2]
iris[,1:2]
head(iris[,1:2])
head(iris)
Exponential = function(N0 = 1, r= 1, generations = 10){
#Runs a simulation of exponential growth
#Returns a vector of length generations
N = rep(NA, generations) # creates a vector of NA
N[1] = N0
for(t in 2:generations){
N[t] = N[t-1] * exp(r)
browser()
}
return(N)
}
plot(Exponential(), type = "l", main = "Exponential growth")
c()
doit = function(x){
temp_x = sample(x, replace = T)
if(length(unique(temp_x))>30) {# Only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else{
stop("Couldn't calculate mean: too few unique values")
}
}
popn = rnorm(50)
hsit(popn)
doit = function(x){
temp_x = sample(x, replace = T)
if(length(unique(temp_x))>30) {# Only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else{
stop("Couldn't calculate mean: too few unique values")
}
}
popn = rnorm(50)
hist(popn)
unique(temp_x)
unique(10)
unique(2,3,4,5)
unique(c(2,3,4,5))
unique(c(2,3,4,2))
Exponential = function(N0 = 1, r= 1, generations = 10){
#Runs a simulation of exponential growth
#Returns a vector of length generations
N = rep(NA, generations) # creates a vector of NA
N[1] = N0
for(t in 2:generations){
N[t] = N[t-1] * exp(r)
#browser()
}
return(N)
}
plot(Exponential(), type = "l", main = "Exponential growth")
doit = function(x){
temp_x = sample(x, replace = T)
if(length(unique(temp_x))>30) {# Only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else{
stop("Couldn't calculate mean: too few unique values")
}
}
doit = function(x){
temp_x = sample(x, replace = T)
if(length(unique(temp_x))>30) {# Only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else{
stop("Couldn't calculate mean: too few unique values")
}
}
popn = rnorm(50)
hist(popn)
lapply(1:15, function(i) doit(popn))
doit = function(x){
temp_x = sample(x, replace = T)
if(length(unique(temp_x))>30) {# Only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else{
stop("Couldn't calculate mean: too few unique values")
}
}
doit = function(x){
temp_x = sample(x, replace = F)
if(length(unique(temp_x))>30) {# Only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else{
stop("Couldn't calculate mean: too few unique values")
}
}
popn = rnorm(50)
hist(popn)
lapply(1:15, function(i) doit(popn))
Exponential = function(N0 = 1, r= 1, generations = 10){
#Runs a simulation of exponential growth
#Returns a vector of length generations
N = rep(NA, generations) # creates a vector of NA
N[1] = N0
for(t in 2:generations){
N[t] = N[t-1] * exp(r)
#browser()  # A break point imported
}
return(N)
}
plot(Exponential(), type = "l", main = "Exponential growth")
doit = function(x){
temp_x = sample(x, replace = T)
if(length(unique(temp_x))>30) {# Only take mean if sample was sufficient
print(paste("Mean of this sample was:", as.character(mean(temp_x))))
}
else{
stop("Couldn't calculate mean: too few unique values")
}
}
popn = rnorm(50)
hist(popn)
lapply(1:15, function(i) doit(popn))
result = lapply(1:15, function(i) try(doit(popn), F))
class(result)
result
result = vector("list", 15)  # Preallocate/Initialize
result
install.packages("tidyverse")
Ricker = function(N0 = 1, r = 1, K = 10, generations = 50)
{
#Runs a simulation of the Ricker model, returns a vector of length generations
N = rep(NA, generations)
N[1] = N0
for(t in 2:generations)
{
N[t] = N[t-1] * exp(r*(1.0 - (N[t-1]/K)))
}
return(N)
}
plot(Ricker(generations = 10), type = "l")
plot(Ricker(generations = 10), type = "b")
runif(10)
runif(10,0.5,1.5)
length(runif(1000,.5,1.5))
head(runif(1000,.5,1.5))
rnorm(1,0,sigma)
sigma=0.2
rnorm(1,0,sigma)
